export const sungshiftdang = `
\\begin{problem}{성싶당}{표준 입력(stdin)}{표준 출력(stdout)}{3\\,초}{1024\\,MB}

최근 수현이는 빵가게 <성싶당>을 차렸다. 겉은 과자보다 바삭하고 속은 포근할 정도로 촉촉한 빵을 매일 구워 파는 성싶당은 얼마 지나지 않아 인스타 빵지순례 명소가 될 정도로 인기 베이커리가 되었지만, 안타깝게도 강화된 거리두기로 손님이 매우 줄었다.

성싶당은 시대의 흐름에 따라 배달 주문을 받기 시작했다. 빵 하나에는 $N$가지의 재료가 들어가는데, 각각의 재료는 두 가지 바리에이션이 있어서 두 가지 중 하나를 고를 수 있다. 예를 들자면, 반죽은 밀가루나 통밀가루 중 하나를 고를 수 있고, 시럽은 메이플 시럽과 딸기 시럽 중 하나를 고를 수 있는 식이다. 따라서 $2^N$종류의 빵이 만들어질 수 있다. 아니나 다를까 맙소사, 배달 첫날부터 $2^N$개의 주문이 들어왔는데 주문으로 들어온 빵의 종류가 모두 달랐다.

아무리 빵 굽기에 숙련된 수현이라도 $2^N$개의 주문을 처리하는 건 무리였다. 다행히도 성싶당의 직원들은 각자 재료 한 종류씩을 빠르게 준비할 수 있어서, 여러 직원이 한 재료씩 각자 동시에 준비하면 시간을 절약할 수 있다. 따라서 수현이는 다음 식이 최소가 되도록 주문들의 순서를 바꾸려고 한다.

\\[\\sum_{i=1}^{2^N-1} (\\text{$i$번째 주문과 $i + 1$번째 주문에서 겹치는 재료의 종류의 수})\\]

단, 첫 번째로 주문한 손님의 빵은 첫 번째로 만들려고 한다. $N$과 첫 번째 손님의 주문이 주어질 때, 위의 식이 최소가 되도록 하려면 주문들을 어떤 순서로 처리해야 하는지 알려주자.

\\InputFile
다음과 같이 입력이 주어진다.

\\begin{examplebox}
$N$

$p_1$
\\end{examplebox}

\\begin{itemize}
    \\item $N$은 성싶당 빵에 들어가는 재료의 수다. ($1 \\leq N \\leq 20$)
    \\item $p_1$은 첫 번째 주문을 의미하는 문자열이다. $i$번째 문자는 $i$번째 재료 종류를 의미하며, 배달 주문 시스템의 대역폭을 아끼기 위해 한 바리에이션을 \\t{0}으로, 다른 바리에이션을 \\t{1}로 표현한다. ($\\left|c_0\\right|=N$)
\\end{itemize}

\\OutputFile
주문 $2^N$개를 $p_1$으로 시작해 한 줄에 하나씩 출력한다. 각 주문은 입력 형식과 같은 방식으로, $i$번째 문자가 $i$번째 재료의 종류가 되도록 길이 $N$의 문자열을 구성해 출력한다.

조건을 만족하는 주문 순서가 여러 개 있을 경우 그중 하나만 출력한다.

\\Examples

\\begin{example}
\\exmp{
1
0
}{%
0
1
}%
\\exmp{
2
00
}{%
00
11
10
01
}%
\\end{example}

\\end{problem}

`;

export const physed = `
\\begin{problem}{코딩은 체육과목 입니다}{표준 입력(stdin)}{표준 출력(stdout)}{0.5\\,초}{1024\\,MB}

\\begin{figure}[h!]
    \\centering
      \\includegraphics[width=.4\\linewidth]{../pictures/long-long-long-img1.png}
    \\end{figure}

오늘은 혜아의 면접 날이다. 면접 준비를 열심히 해서 앞선 질문들을 잘 대답한 혜아는 이제 마지막으로 칠판에 직접 코딩하는 문제를 받았다. 혜아가 받은 문제는 두 수를 더하는 문제였다. C++ 책을 열심히 읽었던 혜아는 간단히 두 수를 더하는 코드를 칠판에 적었다. 코드를 본 면접관은 다음 질문을 했다. \`\`만약, 입출력이 $N$바이트 크기의 정수라면 프로그램을 어떻게 구현해야 할까요?"

혜아는 책에 있는 정수 자료형과 관련된 내용을 기억해 냈다. 책에는 \\t{long int}는 $4$바이트 정수까지 저장할 수 있는 정수 자료형이고 \\t{long long int}는 $8$바이트 정수까지 저장할 수 있는 정수 자료형이라고 적혀 있었다. 혜아는 이런 생각이 들었다. \`\`\\t{int} 앞에 \\t{long}을 하나씩 더 붙일 때마다 $4$바이트씩 저장할 수 있는 공간이 늘어나는 걸까? 분명 \\t{long long long int}는 $12$바이트, \\t{long long long long int}는 $16$바이트까지 저장할 수 있는 정수 자료형일 거야!" 그렇게 혜아는 당황하는 면접관의 얼굴을 뒤로한 채 칠판에 정수 자료형을 써 내려가기 시작했다.

혜아가 $N$바이트 정수까지 저장할 수 있다고 생각해서 칠판에 쓴 정수 자료형의 이름은 무엇일까?

\\InputFile
첫 번째 줄에는 문제의 정수 $N$이 주어진다. $(4 \\le N \\le 1\\,000$; $N$은 $4$의 배수$)$

\\OutputFile
혜아가 $N$바이트 정수까지 저장할 수 있다고 생각하는 정수 자료형의 이름을 출력하여라.

\\Examples
\\begin{example}
    \\exmp{
        4
    }{%
        long int
    }%
    \\exmp{
        20
    }{%
        long long long long long int
    }%
\\end{example}

\\Note

출력에서 \\t{long}과 \\t{long}, \\t{long}과 \\t{int} 사이에는 공백이 하나씩 들어간다.

실제로 C++에서 각 정수 자료형이 저장할 수 있는 수의 크기는 환경에 따라 달라질 수 있다. 덧붙여, 실제로 문제 내용과 같이 \\t{long long long int}와 같은 자료형을 사용한 코드를 GCC의 C++ 컴파일러를 사용해 컴파일하려고 할 경우 \\texttt{'long long long' is too long for GCC}라는 에러 메시지와 함께 컴파일되지 않는다.

\\end{problem}
`;

export const raspberries = `
\\begin{problem}{라즈베리 파이}{표준 입력(stdin)}{표준 출력(stdout)}{2\\,초}{1024\\,MB}
    
    \\begin{figure}[!htbp]
        \\centering
        \\begin{minipage}[t]{.5\\textwidth}\\centering%
            \\includegraphics[width=\\textwidth]{../hanbyeol.png}
        \\end{minipage}
    \\end{figure}
    
    한별이는 $3$년 만에 오프라인으로 개최되는 UCPC 본선을 맞아 특별한 이벤트를 계획했다. 바로 참가자들과 라즈베리 파이를 나눠 먹는 것이다! 한별이는 원기둥 모양의 파이를 모든 조각이 밑면이 부채꼴인 기둥 모양이 되도록 $M$등분하고, 각 조각 위에 라즈베리를 하나씩 놓았다. 그리고 각 조각에 시계 방향 순서대로 $1$번에서 $M$번까지 번호를 붙였다.

    한별이는 대회에 총 $N$($N \\leq M$)명의 참가자가 참가한다는 말을 듣고, 각 참가자에게 몇 번째 조각을 나눠줄지 미리 정해 두었다. 마침내 모든 참가자가 대회장에 도착하고 한별이가 계획대로 파이 조각을 나눠주려는 순간, 한 참가자가 파이 위에 올려진 한 라즈베리를 가리키며 \`\`나에게 저 라즈베리를 주지 않는다면 문제를 $10$분 만에 다 풀어버리겠다!''라고 선언했다. 그러자 다른 참가자들도 하나둘씩 본인이 원하는 라즈베리를 말하기 시작했고, 결국 모든 참가자가 본인이 먹고 싶은 라즈베리를 하나씩 말하고 돌아갔다.

    한별이는 참가자들의 요구를 들어주기 위해 파이에 장식된 라즈베리들의 위치를 조정하려 한다. 그러나 이 라즈베리는 환경 변화에 민감해서 다음과 같은 방법으로 옮기지 않으면 금방 상해 버리고 만다.

    \\begin{itemize}
        \\item 조각 하나를 선택하여, 그 조각에 있는 모든 라즈베리를 바로 다음 조각으로 옮긴다.
    \\end{itemize}

    여기서 $1$번 조각의 바로 다음 조각은 $2$번 조각, $2$번 조각의 바로 다음 조각은 $3$번 조각, $\\cdots$, $M-1$번 조각의 바로 다음 조각은 $M$번 조각, $M$번 조각의 바로 다음 조각은 $1$번 조각이다.

    라즈베리는 상하면 다른 라즈베리에도 나쁜 영향을 주므로, 한별이는 어떤 라즈베리도 상하지 않도록 하면서 라즈베리를 최소한으로 옮겨서 모든 참가자의 요구를 들어주려고 한다. 대회가 $10$분 만에 끝나 버리는 참사를 막기 위해 한별이를 도와주자.

    단, 참가자들은 자신이 원하는 라즈베리와 다른 라즈베리를 같이 먹게 되는 것은 신경 쓰지 않으며, 라즈베리를 옮길 때 라즈베리 여러 개가 있는 조각을 선택하더라도 이동 횟수는 한 번으로 친다.


    \\InputFile
    
    첫 번째 줄에는 파이의 조각 수 $M$과 대회 참가자의 수 $N$이 공백으로 구분되어 주어진다. $(1 \\leq N \\leq M \\leq 300\\,000)$

    두 번째 줄에는 $N$개의 정수 $a_1, \\cdots, a_N$이 공백으로 구분되어 주어진다. $(1 \\leq a_i \\leq M)$ $a_i$는 $i$번째 참가자에게 배정한 파이 조각의 번호를 의미하며, 모든 $a_i$는 서로 다르다.

    세 번째 줄에는 $N$개의 정수 $b_1, \\cdots, b_N$이 공백으로 구분되어 주어진다. $(1 \\leq b_i \\leq M)$ $b_i$는 $i$번째 참가자가 원하는 라즈베리가 위치한 파이 조각의 번호를 의미한다.

    
    \\OutputFile
    
    라즈베리를 상하지 않게 하면서 모든 참가자의 요구를 들어줄 수 있으면 라즈베리의 이동 횟수의 최솟값을 출력한다. 그렇지 않은 경우 $-1$을 출력한다.

    \\Examples
    \\begin{example}
        \\exmp{
            5 2
            3 5
            1 4
        }{%
            3
        }%
        \\exmp{
            3 2
            3 2
            1 2
        }{%
            5
        }%
        \\exmp{
            4 3
            1 3 4
            1 1 3
        }{%
            -1
        }%
    \\end{example}
    
    \\Note
    첫 번째 예제에서, 다음과 같은 방법으로 라즈베리를 총 $3$번 옮겼을 때 모든 참가자의 요구를 들어줄 수 있다. 이보다 적게 옮기는 방법은 없다.
    \\begin{enumerate}[i.]
        \\item $1$번 조각에 있는 모든 라즈베리를 $2$번 조각으로 옮긴다.
        \\item $2$번 조각에 있는 모든 라즈베리를 $3$번 조각으로 옮긴다.
        \\item $4$번 조각에 있는 모든 라즈베리를 $5$번 조각으로 옮긴다.
    \\end{enumerate}
    
\\end{problem}
`;
